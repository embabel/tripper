<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Planning your Journey &ndash; Embabel Travel Planner</title>
    <script src="https://unpkg.com/htmx.org@2.0.5"></script>
    <script src="https://unpkg.com/htmx.org@2.2.2/dist/ext/sse.js"></script>
    <link href="/css/dark.css" rel="stylesheet">
    <style>
        #current-plan {
            position: sticky;
            top: 0;
            background-color: #1a1a1a;
            padding: 15px;
            border-bottom: 1px solid #333;
            margin-bottom: 20px;
            z-index: 100;
            display: none;
        }

        #current-plan.visible {
            display: block;
        }
    </style>
</head>
<body>
<div class="container">
    <h2>Embabel Journey Planner</h2>
    <div id="journey-container">
        <div id="journey-status">
            <div class="working">
                <h3>Planning your journey...</h3>
                <p th:text="${travelBrief.brief}"></p>

                <div class="process-controls">
                    <a th:href="@{/api/v1/process/{id}(id=${processId})}"
                       target="_blank"
                       class="btn btn-primary">
                        Open Process <span th:text="${processId}"></span>
                    </a>
                    <button type="button"
                            th:hx-delete="@{/api/v1/process/{id}(id=${processId})}"
                            hx-confirm="Are you sure you want to kill this process?"
                            hx-target="this"
                            hx-swap="outerHTML"
                            class="scary-delete-btn">
                        Kill Process
                    </button>
                </div>
                <div class="spinner"></div>
            </div>
        </div>
        <div id="current-plan">
            <h3>Current Plan</h3>
            <div id="plan-content"></div>
        </div>
        <div id="sse-updates">
            <p id="init-message">Initializing...</p>
        </div>
    </div>

    <!-- Template for process updates -->
    <template id="update-template">
        <div class="process-update">
            <div class="update-header" data-field="header"></div>
            <div class="update-details" data-field="details"></div>
            <div class="update-details" data-field="event-type"></div>
            <pre class="json-content hidden" data-field="json"></pre>
        </div>
    </template>
</div>

<script>
    const processId = '[[${processId}]]';
    const eventSource = new EventSource(`/events/process/${processId}`);
    const updatesContainer = document.getElementById('sse-updates');
    const initMessage = document.getElementById('init-message');
    const updateTemplate = document.getElementById('update-template');
    const currentPlanElement = document.getElementById('current-plan');
    const planContentElement = document.getElementById('plan-content');

    // Store tool call elements by their ID for later updates
    const toolCallElements = new Map();

    function createUpdateElement(data) {
        // Clone the template
        const clone = updateTemplate.content.cloneNode(true);
        const updateDiv = clone.querySelector('.process-update');

        // Get all the field elements
        const headerEl = updateDiv.querySelector('[data-field="header"]');
        const detailsEl = updateDiv.querySelector('[data-field="details"]');
        const eventTypeEl = updateDiv.querySelector('[data-field="event-type"]');
        const jsonEl = updateDiv.querySelector('[data-field="json"]');

        // Set content based on event type
        let headerText = "";
        let detailsText = "";
        let showJson = false;

        switch (data.type) {
            case 'AgentProcessPlanFormulatedEvent':
                headerText = `ðŸ“‹ Plan Formulated`;
                if (data.plan && data.plan.actions) {
                    const planText = data.plan.actions.map(action => action.name).join('\nâ€¢ ');
                    detailsText = `â€¢ ${planText}`;

                    // Update the sticky plan area without causing focus/scroll
                    planContentElement.innerHTML = `<p>â€¢ ${planText}</p>`;
                    // currentPlanElement.classList.add('visible');
                    // Prevent automatic scrolling to this element
                } else {
                    detailsText = 'Plan details not available';
                }
                break;

            case 'ActionExecutionStartEvent':
                headerText = `ðŸš€ Executing Action`;
                detailsText = data.action?.name?.replace('_', ' ') || 'Unknown action';
                break;
            case 'ToolCallRequestEvent':
                headerText = `ðŸ”§ Tool Call`;
                detailsText = `${data.tool || 'Unknown tool'}`;
                // Store the element reference with the tool call ID
                if (data.id) {
                    updateDiv.setAttribute('data-tool-call-id', data.correlationId);
                    toolCallElements.set(data.id, updateDiv);
                }
                break;
            // case 'ToolCallResponseEvent':
            //     // Instead of creating a new element, find the corresponding request element
            //     if (data.request?.correlationId && toolCallElements.has(data.request?.correlationId)) {
            //         return null; // Return null to indicate no new element should be created
            //     }
            //     headerText = `ðŸ”§ Tool Response`;
            //     detailsText = 'Tool response received';
            //     showJson = true;
            //     jsonEl.textContent = JSON.stringify(data.response, null, 2);
            //     break;
            case 'LlmRequestEvent':
                headerText = `ðŸ¤– LLM Call - ${data.llm?.name}`;
                detailsText = data.prompt;
                break;
            case 'LlmResponseEvent':
                headerText = `ðŸ’¬ LLM Response - ${data.llm.name}`;
                showJson = true;
                jsonEl.textContent = JSON.stringify(data.response, null, 2);
                break;
            default:
                // headerText = `âš¡ ${data.type.replace('Event', '')}`;
                // detailsText = 'Processing...';
                // Don't add
                return null;
        }

        // Update element content
        headerEl.textContent = headerText;
        detailsEl.textContent = detailsText;
        // eventTypeEl.textContent = `Event: ${data.type}`;

        // Show/hide JSON based on event type
        if (showJson) {
            jsonEl.classList.remove('hidden');
        }

        return updateDiv;
    }

    function updateToolCallElement(data) {
        if (!data.request?.correlationId || !toolCallElements.has(data.request.correlationId)) {
            return false;
        }

        const toolCallElement = toolCallElements.get(data.request.correlationId);
        const detailsEl = toolCallElement.querySelector('[data-field="details"]');
        const jsonEl = toolCallElement.querySelector('[data-field="json"]');

        // Update the header to indicate it's now a response
        const headerEl = toolCallElement.querySelector('[data-field="header"]');
        headerEl.textContent = 'ðŸ”§ Tool Call (Completed)';

        // Append response to details
        const originalDetails = detailsEl.textContent;
        detailsEl.textContent = `${originalDetails}\nResponse received`;

        // Show the JSON response
        jsonEl.textContent = JSON.stringify(data.response, null, 2);
        jsonEl.classList.remove('hidden');

        return true;
    }

    eventSource.addEventListener('agent-process-event', function (event) {
        const data = JSON.parse(event.data);

        // Handle completion events
        if (data.type === "GoalAchievedEvent") {
            eventSource.close();
            window.location.href = `/travel/journey/status/${processId}`;
            return;
        }

        // Remove initialization message on first real update
        if (initMessage && !initMessage.classList.contains('hidden')) {
            initMessage.classList.add('hidden');
        }

        // Handle tool call responses by updating existing elements
        if (data.type === 'ToolCallResponseEvent') {
            const updated = updateToolCallElement(data);
            if (updated) {
                // No need to create a new element
                return;
            }
        }

        // Create and append new update element
        const updateElement = createUpdateElement(data);
        if (updateElement) {  // Only append if an element was created
            updatesContainer.appendChild(updateElement);
            // Auto-scroll to latest update
            updateElement.scrollIntoView({behavior: 'smooth'});
        }
    });

    eventSource.addEventListener('error', function (event) {
        console.error('EventSource error:', event);
        const errorUpdate = createUpdateElement({
            type: 'ConnectionError',
            message: 'Connection to server lost'
        });
        updatesContainer.appendChild(errorUpdate);
    });
</script>
</body>
</html>